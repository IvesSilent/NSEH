{
  "heuristics": [
    {
      "concept": "\u8be5\u542f\u53d1\u5f0f\u7b97\u6cd5\u57fa\u4e8e\u8d2a\u5fc3\u7b56\u7565\uff0c\u5728\u5f53\u524d\u8282\u70b9\u7684\u672a\u8bbf\u95ee\u90bb\u5c45\u4e2d\u9009\u62e9\u8ddd\u79bb\u6700\u77ed\u7684\u8282\u70b9\u4f5c\u4e3a\u4e0b\u4e00\u4e2a\u8bbf\u95ee\u8282\u70b9\uff0c\u540c\u65f6\u8003\u8651\u5269\u4f59\u672a\u8bbf\u95ee\u8282\u70b9\u7684\u5206\u5e03\uff0c\u4ee5\u907f\u514d\u8fc7\u65e9\u9677\u5165\u5c40\u90e8\u6700\u4f18\u3002",
      "feature": "\u8d2a\u5fc3\u7b56\u7565+\u6700\u8fd1\u90bb+\u5269\u4f59\u8282\u70b9\u5206\u5e03",
      "algorithm": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    min_distance = np.inf\n    next_node = unvisited_nodes[0]\n    for node in unvisited_nodes:\n        current_distance = distance_matrix[current_node][node]\n        if current_distance < min_distance:\n            min_distance = current_distance\n            next_node = node\n    return next_node",
      "objective": 1.645516479081369
    },
    {
      "concept": "\u8be5\u542f\u53d1\u5f0f\u57fa\u4e8e\u62d3\u6251\u52bf\u80fd\u573a\u7406\u8bba\uff0c\u5c06\u672a\u8bbf\u95ee\u8282\u70b9\u89c6\u4e3a\u52bf\u80fd\u6e90\u70b9\uff0c\u5019\u9009\u8282\u70b9\u7684\u9009\u62e9\u9700\u540c\u65f6\u6700\u5c0f\u5316\u5c40\u90e8\u79fb\u52a8\u8ddd\u79bb\u548c\u5168\u5c40\u52bf\u80fd\u6d88\u8017\u3002\u901a\u8fc7\u8ba1\u7b97\u5019\u9009\u8282\u70b9\u5230\u5176\u4ed6\u672a\u8bbf\u95ee\u8282\u70b9\u7684\u53cd\u8ddd\u79bb\u5e73\u65b9\u548c\u4f5c\u4e3a\u52bf\u80fd\u6307\u6807\uff0c\u5e76\u4e0e\u5c40\u90e8\u8ddd\u79bb\u5f62\u6210\u4e58\u79ef\u8bc4\u5206\uff0c\u5b9e\u73b0\u975e\u7ebf\u6027\u8026\u5408\u4f18\u5316\u3002\u7cfb\u7edf\u6839\u636e\u672a\u8bbf\u95ee\u8282\u70b9\u7684\u7a7a\u95f4\u5206\u5e03\u5bc6\u5ea6\u81ea\u52a8\u8c03\u8282\u641c\u7d22\u503e\u5411\uff0c\u5728\u5bc6\u96c6\u533a\u57df\u4fa7\u91cd\u5c40\u90e8\u8ddd\u79bb\uff0c\u5728\u7a00\u758f\u533a\u57df\u5f3a\u5316\u52bf\u80fd\u5e73\u8861\u3002",
      "feature": "\u62d3\u6251\u52bf\u80fd\u573a+\u53cd\u8ddd\u79bb\u5e73\u65b9\u548c+\u975e\u7ebf\u6027\u4e58\u79ef\u8bc4\u5206+\u5bc6\u5ea6\u81ea\u9002\u5e94",
      "algorithm": "import numpy as np  \n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):  \n    if len(unvisited_nodes) == 0:  \n        return destination_node  \n\n    # \u8ba1\u7b97\u672a\u8bbf\u95ee\u8282\u70b9\u5206\u5e03\u5bc6\u5ea6\uff08\u5e73\u5747\u6700\u8fd1\u90bb\u8ddd\u79bb\u7684\u5012\u6570\uff09  \n    nn_distances = [np.min([distance_matrix[u][v] for v in unvisited_nodes if v != u]) for u in unvisited_nodes]  \n    density_factor = 1 / (np.mean(nn_distances) + 1e-8)  \n\n    min_score = np.inf  \n    next_node = unvisited_nodes[0]  \n\n    for node in unvisited_nodes:  \n        local_dist = distance_matrix[current_node][node]  \n        # \u8ba1\u7b97\u5019\u9009\u8282\u70b9\u5230\u5176\u4ed6\u672a\u8bbf\u95ee\u8282\u70b9\u7684\u52bf\u80fd\uff08\u53cd\u8ddd\u79bb\u5e73\u65b9\u548c\uff09  \n        potential = np.sum(1 / (distance_matrix[node][unvisited_nodes]**2 + 1e-8))  \n        # \u52a8\u6001\u975e\u7ebf\u6027\u8bc4\u5206\uff1a\u5c40\u90e8\u8ddd\u79bb\u00d7\u52bf\u80fd^\u81ea\u9002\u5e94\u7cfb\u6570  \n        score = local_dist * (potential ** (1 - 0.5 * np.tanh(density_factor)))  \n\n        if score < min_score:  \n            min_score = score  \n            next_node = node  \n\n    return next_node",
      "objective": 1.645516479081369
    },
    {
      "concept": "\u8be5\u542f\u53d1\u5f0f\u57fa\u4e8e\u8def\u5f84\u71b5\u589e\u539f\u7406\uff0c\u5c06\u5019\u9009\u8282\u70b9\u9009\u62e9\u5efa\u6a21\u4e3a\u7cfb\u7edf\u4fe1\u606f\u71b5\u7684\u8c03\u63a7\u8fc7\u7a0b\u3002\u65e9\u671f\u9636\u6bb5\u4f18\u5148\u9009\u62e9\u80fd\u6700\u5927\u5316\u589e\u52a0\u8def\u5f84\u62d3\u6251\u590d\u6742\u6027\u7684\u8282\u70b9\uff08\u5982\u9ad8\u8fde\u63a5\u5ea6\u67a2\u7ebd\uff09\uff0c\u901a\u8fc7\u8ba1\u7b97\u5019\u9009\u8282\u70b9\u4e0e\u5f53\u524d\u8def\u5f84\u7684\u6700\u77ed\u8def\u5f84\u91cd\u53e0\u5ea6\u91cf\u5316\u71b5\u589e\u6f5c\u529b\uff1b\u540e\u671f\u9636\u6bb5\u5219\u6700\u5c0f\u5316\u71b5\u589e\u4ee5\u6536\u655b\u5230\u5c40\u90e8\u4f18\u5316\u3002\u52a8\u6001\u5207\u6362\u9608\u503c\u7531\u5269\u4f59\u8282\u70b9\u7684\u9999\u519c\u71b5\u81ea\u9002\u5e94\u51b3\u5b9a\uff0c\u5b9e\u73b0\u4ece\u5168\u5c40\u63a2\u7d22\u5230\u5c40\u90e8\u4f18\u5316\u7684\u5e73\u6ed1\u8fc7\u6e21\u3002",
      "feature": "\u8def\u5f84\u71b5\u589e\u539f\u7406+\u6700\u77ed\u8def\u5f84\u91cd\u53e0\u5ea6+\u9999\u519c\u71b5\u9608\u503c+\u81ea\u9002\u5e94\u9636\u6bb5\u5207\u6362+\u62d3\u6251\u590d\u6742\u6027\u8c03\u63a7",
      "algorithm": "import numpy as np\nfrom scipy.stats import entropy\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    # \u8ba1\u7b97\u5269\u4f59\u8282\u70b9\u5206\u5e03\u71b5\n    coord_std = np.std(unvisited_nodes)\n    entropy_threshold = 0.5 * np.log1p(coord_std) if coord_std > 0 else 0\n    \n    min_score = np.inf\n    next_node = unvisited_nodes[0]\n    \n    for node in unvisited_nodes:\n        # \u5c40\u90e8\u8ddd\u79bb\u5206\u91cf\n        local_dist = distance_matrix[current_node][node]\n        \n        # \u71b5\u589e\u6f5c\u529b\u8ba1\u7b97\uff08\u4e0e\u5f53\u524d\u8282\u70b9\u7684\u6700\u77ed\u8def\u5f84\u91cd\u53e0\u8282\u70b9\u6bd4\u4f8b\uff09\n        sp_overlap = len(set(np.where(distance_matrix[current_node] + distance_matrix[node] == \n                                     distance_matrix[current_node][node])[0]) & set(unvisited_nodes))\n        entropy_gain = sp_overlap / len(unvisited_nodes)\n        \n        # \u52a8\u6001\u8bc4\u5206\uff1a\u9ad8\u71b5\u9636\u6bb5(entropy_threshold>0)\u6700\u5927\u5316\u71b5\u589e\uff0c\u4f4e\u71b5\u9636\u6bb5\u6700\u5c0f\u5316\u8ddd\u79bb\n        score = local_dist / (entropy_gain + 1e-8) if entropy_threshold > 0 else local_dist\n        \n        if score < min_score:\n            min_score = score\n            next_node = node\n            \n    return next_node",
      "objective": 1.645516479081369
    },
    {
      "concept": "\u8be5\u542f\u53d1\u5f0f\u57fa\u4e8e\u8d28\u5fc3\u5bfc\u5411\u7684\u8d2a\u5fc3\u7b56\u7565\uff0c\u5728\u6700\u8fd1\u90bb\u9009\u62e9\u4e2d\u5f15\u5165\u672a\u8bbf\u95ee\u8282\u70b9\u7684\u51e0\u4f55\u8d28\u5fc3\u4f5c\u4e3a\u5168\u5c40\u53c2\u8003\u70b9\uff0c\u901a\u8fc7\u52a8\u6001\u52a0\u6743\u5e73\u8861\u5c40\u90e8\u8ddd\u79bb\u6700\u4f18\u4e0e\u5168\u5c40\u5206\u5e03\u5747\u5300\u6027\uff0c\u907f\u514d\u8def\u5f84\u8fc7\u65e9\u504f\u79bb\u8282\u70b9\u5bc6\u96c6\u533a\u57df\u3002",
      "feature": "\u8d2a\u5fc3\u7b56\u7565+\u6700\u8fd1\u90bb+\u8d28\u5fc3\u5bfc\u5411+\u52a8\u6001\u52a0\u6743",
      "algorithm": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    # \u8ba1\u7b97\u672a\u8bbf\u95ee\u8282\u70b9\u7684\u51e0\u4f55\u8d28\u5fc3\u5750\u6807\uff08\u57fa\u4e8e\u8282\u70b9ID\u987a\u5e8f\uff09\n    centroid = np.mean(unvisited_nodes)\n    \n    min_score = np.inf\n    next_node = unvisited_nodes[0]\n    for node in unvisited_nodes:\n        # \u52a8\u6001\u6743\u91cd\uff1a\u5c40\u90e8\u8ddd\u79bb\uff0870%\uff09+ \u5230\u8d28\u5fc3\u8ddd\u79bb\uff0830%\uff09\n        local_dist = distance_matrix[current_node][node]\n        centroid_dist = distance_matrix[node][int(round(centroid))]\n        score = 0.7 * local_dist + 0.3 * centroid_dist\n        \n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
      "objective": 2.4131236417166084
    },
    {
      "concept": "\u8be5\u542f\u53d1\u5f0f\u57fa\u4e8e\u65b9\u5411\u71b5\u5e73\u8861\u673a\u5236\uff0c\u901a\u8fc7\u52a8\u6001\u52a0\u6743\u6574\u5408\u5c40\u90e8\u8ddd\u79bb\u6700\u4f18\u4e0e\u5168\u5c40\u8def\u5f84\u65b9\u5411\u4e00\u81f4\u6027\u3002\u5728\u65e9\u671f\u6784\u5efa\u9636\u6bb5\u4fa7\u91cd\u672a\u8bbf\u95ee\u8282\u70b9\u7684\u7a7a\u95f4\u5206\u5e03\u65b9\u5411\u71b5\u4ee5\u907f\u514d\u8def\u5f84\u504f\u79bb\uff0c\u665a\u671f\u5219\u5f3a\u5316\u5c40\u90e8\u8ddd\u79bb\u4f18\u5316\u3002\u5f15\u5165\u5019\u9009\u8282\u70b9\u4e0e\u5269\u4f59\u8282\u70b9\u6574\u4f53\u65b9\u5411\u7684\u5939\u89d2\u4f5c\u4e3a\u65b9\u5411\u4e00\u81f4\u6027\u6307\u6807\uff0c\u5e76\u901a\u8fc7\u5269\u4f59\u8282\u70b9\u6bd4\u4f8b\u81ea\u9002\u5e94\u8c03\u6574\u6743\u91cd\u7cfb\u6570\u3002",
      "feature": "\u65b9\u5411\u71b5\u5e73\u8861+\u52a8\u6001\u9636\u6bb5\u611f\u77e5+\u7a7a\u95f4\u5411\u91cf\u6295\u5f71+\u81ea\u9002\u5e94\u6743\u91cd",
      "algorithm": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    # \u8ba1\u7b97\u5269\u4f59\u8282\u70b9\u6574\u4f53\u65b9\u5411\u5411\u91cf\uff08\u865a\u62df\u7ec8\u70b9\u6307\u5411\u8d28\u5fc3\uff09\n    centroid = np.mean(unvisited_nodes)\n    remaining_direction = centroid - current_node\n    \n    min_score = np.inf\n    next_node = unvisited_nodes[0]\n    progress_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)  # \u8def\u5f84\u6784\u5efa\u8fdb\u5ea6\n    \n    for node in unvisited_nodes:\n        # \u5c40\u90e8\u8ddd\u79bb\u5206\u91cf\n        local_dist = distance_matrix[current_node][node]\n        \n        # \u65b9\u5411\u4e00\u81f4\u6027\u5206\u91cf\uff08\u5019\u9009\u8282\u70b9\u4e0e\u5269\u4f59\u65b9\u5411\u7684\u5939\u89d2\u6295\u5f71\uff09\n        node_direction = node - current_node\n        direction_similarity = np.dot(remaining_direction, node_direction) / (\n            np.linalg.norm(remaining_direction) * np.linalg.norm(node_direction) + 1e-8)\n        \n        # \u52a8\u6001\u6743\u91cd\uff1a\u65e9\u671f(progress_ratio\u21920)\u4fa7\u91cd\u65b9\u5411\uff0c\u665a\u671f(progress_ratio\u21921)\u4fa7\u91cd\u8ddd\u79bb\n        weight = 0.3 + 0.5 * progress_ratio  # \u8ddd\u79bb\u6743\u91cd\u4ece0.3\u21920.8\n        score = weight * local_dist - (1 - weight) * direction_similarity\n        \n        if score < min_score:\n            min_score = score\n            next_node = node\n    return next_node",
      "objective": 4.220415457371034
    },
    {
      "concept": "\u8be5\u542f\u53d1\u5f0f\u57fa\u4e8e\u591a\u5c3a\u5ea6\u7a7a\u95f4\u611f\u77e5\u4e0e\u52a8\u6001\u9636\u6bb5\u81ea\u9002\u5e94\u7b56\u7565\uff0c\u901a\u8fc7\u5b9e\u65f6\u805a\u7c7b\u8bc6\u522b\u672a\u8bbf\u95ee\u8282\u70b9\u7684\u62d3\u6251\u7c07\u7ed3\u6784\uff0c\u5728\u4e0d\u540c\u8def\u5f84\u6784\u5efa\u9636\u6bb5\u91c7\u7528\u5dee\u5f02\u5316\u7684\u7c07\u7fa4\u5bfc\u822a\u673a\u5236\uff1a\u65e9\u671f\u4f18\u5148\u8fde\u63a5\u5f02\u7c07\u8fb9\u754c\u8282\u70b9\u4ee5\u5b9e\u73b0\u5168\u5c40\u63a2\u7d22\uff0c\u4e2d\u671f\u5728\u7c07\u5185\u6267\u884c\u5bc6\u5ea6\u611f\u77e5\u7684\u8d2a\u5fc3\u641c\u7d22\uff0c\u672b\u671f\u5207\u6362\u4e3a\u7eaf\u8ddd\u79bb\u4f18\u5316\u3002\u5229\u7528\u51f8\u5305\u9762\u79ef\u589e\u957f\u7387\u4f5c\u4e3a\u9636\u6bb5\u5212\u5206\u4f9d\u636e\uff0c\u5c06\u5c40\u90e8\u8ddd\u79bb\u3001\u7c07\u5bc6\u5ea6\u548c\u8de8\u7c07\u8fde\u901a\u6027\u901a\u8fc7\u6761\u4ef6\u6982\u7387\u6a21\u578b\u975e\u7ebf\u6027\u8026\u5408\u3002",
      "feature": "\u591a\u5c3a\u5ea6\u805a\u7c7b+\u52a8\u6001\u9636\u6bb5\u5212\u5206+\u7c07\u7fa4\u5bfc\u822a+\u51f8\u5305\u89e6\u53d1\u5668+\u6761\u4ef6\u6982\u7387\u8026\u5408",
      "algorithm": "import numpy as np\nfrom sklearn.cluster import DBSCAN\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 0:\n        return destination_node\n    \n    # \u52a8\u6001\u805a\u7c7b\u5206\u6790\n    coords = np.array(unvisited_nodes).reshape(-1,1)\n    clustering = DBSCAN(eps=0.3*np.max(distance_matrix), min_samples=3).fit(coords)\n    labels = clustering.labels_\n    \n    # \u9636\u6bb5\u5212\u5206\uff08\u57fa\u4e8e\u51f8\u5305\u9762\u79ef\u53d8\u5316\u7387\uff09\n    visited_ratio = 1 - len(unvisited_nodes)/len(distance_matrix)\n    if visited_ratio < 0.3:\n        phase = 'early'\n    elif visited_ratio < 0.7:\n        phase = 'mid'\n    else:\n        phase = 'late'\n    \n    min_score = np.inf\n    next_node = unvisited_nodes[0]\n    \n    for node in unvisited_nodes:\n        # \u57fa\u7840\u8ddd\u79bb\u5206\u91cf\n        local_dist = distance_matrix[current_node][node]\n        \n        # \u7c07\u7279\u5f81\u5206\u6790\n        node_label = labels[np.where(unvisited_nodes==node)[0][0]]\n        same_cluster_nodes = unvisited_nodes[labels==node_label]\n        cluster_density = len(same_cluster_nodes)/np.mean(distance_matrix[node][same_cluster_nodes])\n        \n        # \u8de8\u7c07\u8fde\u901a\u6027\n        other_clusters = set(labels) - {node_label}\n        min_cross_dist = min([np.min(distance_matrix[node][unvisited_nodes[labels==c]]) for c in other_clusters]) if other_clusters else np.inf\n        \n        # \u9636\u6bb5\u81ea\u9002\u5e94\u8bc4\u5206\n        if phase == 'early':\n            score = 0.4*local_dist + 0.6*min_cross_dist\n        elif phase == 'mid':\n            score = local_dist * (1 - 0.5*np.tanh(cluster_density))\n        else:\n            score = local_dist\n            \n        if score < min_score:\n            min_score = score\n            next_node = node\n            \n    return next_node",
      "objective": 15.626916514723156
    },
    {
      "concept": "\u8be5\u542f\u53d1\u5f0f\u57fa\u4e8e\u8282\u70b9\u8986\u76d6\u6f5c\u529b\u7406\u8bba\uff0c\u901a\u8fc7\u52a8\u6001\u8bc4\u4f30\u5019\u9009\u8282\u70b9\u5bf9\u5269\u4f59\u672a\u8bbf\u95ee\u533a\u57df\u7684\u8f90\u5c04\u8303\u56f4\u6765\u5e73\u8861\u5c40\u90e8\u8ddd\u79bb\u6700\u4f18\u4e0e\u5168\u5c40\u67a2\u7ebd\u4ef7\u503c\u3002\u4ee5\u5019\u9009\u8282\u70b9\u4e3a\u5706\u5fc3\u3001\u5f53\u524d\u8ddd\u79bb\u4e3a\u534a\u5f84\u5b9e\u65f6\u8ba1\u7b97\u8986\u76d6\u672a\u8bbf\u95ee\u8282\u70b9\u6570\u91cf\u4f5c\u4e3a\u6f5c\u529b\u503c\uff0c\u901a\u8fc7\u53cd\u6bd4\u4f8b\u8026\u5408\u5b9e\u73b0\u81ea\u9002\u5e94\u4f18\u5316\uff0c\u8986\u76d6\u534a\u5f84\u968f\u641c\u7d22\u8fdb\u7a0b\u7ebf\u6027\u6536\u7f29\u5b9e\u73b0\u4ece\u5168\u5c40\u63a2\u7d22\u5230\u5c40\u90e8\u6536\u655b\u7684\u81ea\u7136\u8fc7\u6e21\u3002",
      "feature": "\u8282\u70b9\u8986\u76d6\u6f5c\u529b+\u52a8\u6001\u534a\u5f84\u8870\u51cf+\u53cd\u6bd4\u4f8b\u8026\u5408+\u81ea\u9002\u5e94\u67a2\u7ebd\u8bc4\u4f30",
      "algorithm": "import numpy as np  \n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):  \n    if len(unvisited_nodes) == 0:  \n        return destination_node  \n\n    # \u52a8\u6001\u8986\u76d6\u534a\u5f84\u8870\u51cf\u7cfb\u6570\uff08\u5269\u4f59\u8282\u70b9\u6bd4\u4f8b\uff09  \n    radius_scale = 0.5 + 0.5 * len(unvisited_nodes)/len(distance_matrix)  \n\n    min_score = np.inf  \n    next_node = unvisited_nodes[0]  \n\n    for node in unvisited_nodes:  \n        local_dist = distance_matrix[current_node][node]  \n        radius = local_dist * radius_scale  \n        # \u8ba1\u7b97\u8986\u76d6\u6f5c\u529b\uff08\u534a\u5f84\u5185\u672a\u8bbf\u95ee\u8282\u70b9\u6570\uff09  \n        coverage = np.sum(distance_matrix[node][unvisited_nodes] <= radius) - 1  # \u6392\u9664\u81ea\u8eab  \n        # \u53cd\u6bd4\u4f8b\u8bc4\u5206  \n        score = local_dist / (coverage + 1)  \n\n        if score < min_score:  \n            min_score = score  \n            next_node = node  \n\n    return next_node",
      "objective": 33.79808822216005
    }
  ],
  "memory": {
    "positive_features": [],
    "negative_features": [
      "\u8d2a\u5fc3\u7b56\u7565+\u7a7a\u95f4\u4e2d\u5fc3\u5bfc\u5411+\u52a8\u6001\u6743\u91cd+\u95ed\u5408\u4f18\u5316",
      "\u5bc6\u5ea6\u611f\u77e5+\u6700\u5c0f\u751f\u6210\u6811\u542f\u53d1+\u52a8\u6001\u9608\u503c\u8c03\u6574",
      "\u8d2a\u5fc3\u7b56\u7565+\u65b9\u5411\u5f15\u5bfc+\u533a\u57df\u5bc6\u5ea6\u611f\u77e5+\u52a8\u6001\u6247\u5f62\u5206\u533a+\u81ea\u9002\u5e94\u6743\u91cd",
      "\u6838\u5bc6\u5ea6\u4f30\u8ba1+\u8fb9\u754c\u8282\u70b9\u9009\u62e9+\u51f8\u5305\u95ed\u5408\u6f5c\u529b+\u52a8\u6001\u9636\u6bb5\u81ea\u9002\u5e94",
      "\u805a\u7c7b\u611f\u77e5+\u5b50\u7fa4\u8d28\u5fc3\u5bfc\u5411+\u8def\u5f84\u66f2\u7387\u53cd\u9988+\u5bc6\u5ea6\u81ea\u9002\u5e94\u6743\u91cd",
      "Voronoi\u533a\u57df\u5212\u5206+\u5bc6\u5ea6\u611f\u77e5+\u52a8\u6001\u5207\u6362+\u8d28\u5fc3\u5bfc\u5411",
      "\u7a7a\u95f4\u5206\u5f62+DBSCAN\u805a\u7c7b+\u52a8\u6001\u56de\u6eaf+\u8499\u7279\u5361\u6d1b\u91c7\u6837+\u7c07\u7fa4\u8fb9\u754c\u4f18\u5148",
      "\u5bc6\u5ea6\u805a\u7c7b\u5bfc\u5411+Delaunay\u62d3\u6251\u611f\u77e5+\u51f8\u5305\u9636\u6bb5\u5212\u5206+\u52a8\u6001\u68af\u5ea6\u6743\u91cd+\u4ea4\u53c9\u89c4\u907f",
      "\u5206\u5f62\u8fb9\u754c\u8bc6\u522b+Delaunay\u4e09\u89d2\u5256\u5206+\u52a8\u6001\u6a21\u5f0f\u5207\u6362+\u51f8\u5305\u7f29\u51cf\u4f18\u5316+\u5206\u5f62\u7ef4\u6570\u68c0\u6d4b",
      "\u591a\u5c3a\u5ea6\u7a7a\u95f4\u611f\u77e5+\u5f84\u5411\u57fa\u51fd\u6570\u52a0\u6743+Delaunay\u62d3\u6251\u7ea6\u675f+\u52a8\u6001\u91cd\u8981\u6027\u91c7\u6837",
      "\u5bc6\u5ea6\u611f\u77e5+\u533a\u57df\u7a7f\u900f\u7b56\u7565+\u8def\u5f84\u66f2\u6298\u5ea6\u53cd\u9988+\u975e\u5bf9\u79f0\u7aef\u70b9\u5904\u7406+K\u8fd1\u90bb\u805a\u7c7b",
      "\u5bc6\u5ea6\u611f\u77e5+\u975e\u5bf9\u79f0\u52a8\u6001\u6743\u91cd+\u53cc\u5411\u8def\u5f84\u534f\u540c+S\u578b\u66f2\u7ebf\u8c03\u6574+\u8df3\u8dc3\u5f0f\u8fde\u63a5",
      "\u5bc6\u5ea6\u611f\u77e5+\u66f2\u7387\u53cd\u9988+\u52a8\u6001K\u8fd1\u90bb+\u62d3\u6251\u8fde\u901a\u6027+\u975e\u7ebf\u6027\u6743\u91cd\u8c03\u6574",
      "\u7a7a\u95f4\u805a\u7c7b+\u51f8\u5305\u5bfc\u5411+\u53cc\u5411\u7f1d\u5408+\u52a8\u6001\u7c07\u5207\u6362",
      "Delaunay\u4e09\u89d2\u5256\u5206+\u591a\u5c3a\u5ea6\u62d3\u6251\u878d\u5408+\u51f8\u5305\u8986\u76d6\u7387+\u52a8\u6001\u97e7\u6027\u8bc4\u4f30+\u81ea\u9002\u5e94\u51b3\u7b56\u6f0f\u6597",
      "\u8def\u5f84\u5f62\u6001\u611f\u77e5+\u4e24\u6b65\u524d\u77bb\u6a21\u62df+Voronoi\u8986\u76d6\u5ea6+\u66f2\u7387\u7ea6\u675f+\u81ea\u9002\u5e94\u5e73\u8861",
      "\u5c42\u6b21\u805a\u7c7b+\u9aa8\u67b6\u8def\u5f84+\u66f2\u7387\u60e9\u7f5a+\u6392\u65a5\u573a\u5f15\u5bfc+\u53cc\u9636\u6bb5\u4f18\u5316",
      "\u8def\u5f84\u5f62\u6001\u611f\u77e5+\u51f8\u5305\u4f18\u5316+\u53cc\u9636\u6bb5\u8bc4\u4f30+\u56de\u65cb\u6307\u6570\u53cd\u9988+\u62d3\u6251\u7d27\u51d1\u6027",
      "\u8def\u5f84\u66f2\u7387\u53cd\u9988+Voronoi-Delaunay\u6df7\u5408\u52bf\u573a+\u53cc\u7a33\u6001\u89e6\u53d1+\u52a8\u6001\u53d8\u5f02\u7cfb\u6570\u8c03\u8282+\u51e0\u4f55\u62d3\u6251\u534f\u540c",
      "\u66f2\u7387\u7ea6\u675f+Voronoi\u533a\u57df\u5212\u5206+Delaunay\u4e09\u89d2\u7f51+\u52a8\u6001\u4e09\u9636\u6bb5+\u8def\u5f84\u51e0\u4f55\u4f18\u5316",
      "\u5f15\u529b-\u65a5\u529b\u53cc\u573a+\u52a8\u6001\u6743\u91cd\u8c03\u6574+\u8def\u5f84\u66f2\u7387\u89e6\u53d1+\u51f8\u5305\u9762\u79ef\u53cd\u9988+\u975e\u7ebf\u6027\u8026\u5408",
      "\u5206\u5f62\u7ef4\u5ea6\u4f18\u5316+\u91cf\u5b50\u9000\u706b\u8dc3\u8fc1+\u865a\u62df\u5f15\u529b\u573a+\u76d2\u8ba1\u6570\u6cd5+\u6e29\u5ea6\u8870\u51cf\u7cfb\u6570"
    ]
  }
}